// Code generated by github.com/tinylib/msgp DO NOT EDIT.

package cmd

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *ActiveWorkerStat) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Curr":
			z.Curr, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Curr")
				return
			}
		case "Avg":
			z.Avg, err = dc.ReadFloat32()
			if err != nil {
				err = msgp.WrapError(err, "Avg")
				return
			}
		case "Max":
			z.Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ActiveWorkerStat) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Curr"
	err = en.Append(0x83, 0xa4, 0x43, 0x75, 0x72, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Curr)
	if err != nil {
		err = msgp.WrapError(err, "Curr")
		return
	}
	// write "Avg"
	err = en.Append(0xa3, 0x41, 0x76, 0x67)
	if err != nil {
		return
	}
	err = en.WriteFloat32(z.Avg)
	if err != nil {
		err = msgp.WrapError(err, "Avg")
		return
	}
	// write "Max"
	err = en.Append(0xa3, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Max)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ActiveWorkerStat) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Curr"
	o = append(o, 0x83, 0xa4, 0x43, 0x75, 0x72, 0x72)
	o = msgp.AppendInt(o, z.Curr)
	// string "Avg"
	o = append(o, 0xa3, 0x41, 0x76, 0x67)
	o = msgp.AppendFloat32(o, z.Avg)
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Max)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ActiveWorkerStat) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Curr":
			z.Curr, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Curr")
				return
			}
		case "Avg":
			z.Avg, bts, err = msgp.ReadFloat32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avg")
				return
			}
		case "Max":
			z.Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ActiveWorkerStat) Msgsize() (s int) {
	s = 1 + 5 + msgp.IntSize + 4 + msgp.Float32Size + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InQueueMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cq":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Curr")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Curr")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Count":
					z.Curr.Count, err = dc.ReadFloat64()
					if err != nil {
						err = msgp.WrapError(err, "Curr", "Count")
						return
					}
				case "Bytes":
					z.Curr.Bytes, err = dc.ReadFloat64()
					if err != nil {
						err = msgp.WrapError(err, "Curr", "Bytes")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Curr")
						return
					}
				}
			}
		case "aq":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Avg")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Avg")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Count":
					z.Avg.Count, err = dc.ReadFloat64()
					if err != nil {
						err = msgp.WrapError(err, "Avg", "Count")
						return
					}
				case "Bytes":
					z.Avg.Bytes, err = dc.ReadFloat64()
					if err != nil {
						err = msgp.WrapError(err, "Avg", "Bytes")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Avg")
						return
					}
				}
			}
		case "pq":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Max")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Count":
					z.Max.Count, err = dc.ReadFloat64()
					if err != nil {
						err = msgp.WrapError(err, "Max", "Count")
						return
					}
				case "Bytes":
					z.Max.Bytes, err = dc.ReadFloat64()
					if err != nil {
						err = msgp.WrapError(err, "Max", "Bytes")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Max")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *InQueueMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "cq"
	err = en.Append(0x83, 0xa2, 0x63, 0x71)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Count"
	err = en.Append(0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Curr.Count)
	if err != nil {
		err = msgp.WrapError(err, "Curr", "Count")
		return
	}
	// write "Bytes"
	err = en.Append(0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Curr.Bytes)
	if err != nil {
		err = msgp.WrapError(err, "Curr", "Bytes")
		return
	}
	// write "aq"
	err = en.Append(0xa2, 0x61, 0x71)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Count"
	err = en.Append(0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Avg.Count)
	if err != nil {
		err = msgp.WrapError(err, "Avg", "Count")
		return
	}
	// write "Bytes"
	err = en.Append(0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Avg.Bytes)
	if err != nil {
		err = msgp.WrapError(err, "Avg", "Bytes")
		return
	}
	// write "pq"
	err = en.Append(0xa2, 0x70, 0x71)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Count"
	err = en.Append(0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Max.Count)
	if err != nil {
		err = msgp.WrapError(err, "Max", "Count")
		return
	}
	// write "Bytes"
	err = en.Append(0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Max.Bytes)
	if err != nil {
		err = msgp.WrapError(err, "Max", "Bytes")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InQueueMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "cq"
	o = append(o, 0x83, 0xa2, 0x63, 0x71)
	// map header, size 2
	// string "Count"
	o = append(o, 0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.Curr.Count)
	// string "Bytes"
	o = append(o, 0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendFloat64(o, z.Curr.Bytes)
	// string "aq"
	o = append(o, 0xa2, 0x61, 0x71)
	// map header, size 2
	// string "Count"
	o = append(o, 0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.Avg.Count)
	// string "Bytes"
	o = append(o, 0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendFloat64(o, z.Avg.Bytes)
	// string "pq"
	o = append(o, 0xa2, 0x70, 0x71)
	// map header, size 2
	// string "Count"
	o = append(o, 0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.Max.Count)
	// string "Bytes"
	o = append(o, 0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendFloat64(o, z.Max.Bytes)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InQueueMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cq":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Curr")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Curr")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Count":
					z.Curr.Count, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Curr", "Count")
						return
					}
				case "Bytes":
					z.Curr.Bytes, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Curr", "Bytes")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Curr")
						return
					}
				}
			}
		case "aq":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avg")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Avg")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Count":
					z.Avg.Count, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Avg", "Count")
						return
					}
				case "Bytes":
					z.Avg.Bytes, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Avg", "Bytes")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Avg")
						return
					}
				}
			}
		case "pq":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Max")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Max")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Count":
					z.Max.Count, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Max", "Count")
						return
					}
				case "Bytes":
					z.Max.Bytes, bts, err = msgp.ReadFloat64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Max", "Bytes")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Max")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InQueueMetric) Msgsize() (s int) {
	s = 1 + 3 + 1 + 6 + msgp.Float64Size + 6 + msgp.Float64Size + 3 + 1 + 6 + msgp.Float64Size + 6 + msgp.Float64Size + 3 + 1 + 6 + msgp.Float64Size + 6 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InQueueStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z InQueueStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	_ = z
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z InQueueStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	_ = z
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InQueueStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z InQueueStats) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProxyMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ptc":
			z.PutTagTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "PutTagTotal")
				return
			}
		case "gtc":
			z.GetTagTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "GetTagTotal")
				return
			}
		case "rtc":
			z.RmvTagTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RmvTagTotal")
				return
			}
		case "gc":
			z.GetTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "GetTotal")
				return
			}
		case "hc":
			z.HeadTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "HeadTotal")
				return
			}
		case "ptf":
			z.PutTagFailedTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "PutTagFailedTotal")
				return
			}
		case "gtf":
			z.GetTagFailedTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "GetTagFailedTotal")
				return
			}
		case "rtf":
			z.RmvTagFailedTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RmvTagFailedTotal")
				return
			}
		case "gf":
			z.GetFailedTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "GetFailedTotal")
				return
			}
		case "hf":
			z.HeadFailedTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "HeadFailedTotal")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProxyMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "ptc"
	err = en.Append(0x8a, 0xa3, 0x70, 0x74, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.PutTagTotal)
	if err != nil {
		err = msgp.WrapError(err, "PutTagTotal")
		return
	}
	// write "gtc"
	err = en.Append(0xa3, 0x67, 0x74, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.GetTagTotal)
	if err != nil {
		err = msgp.WrapError(err, "GetTagTotal")
		return
	}
	// write "rtc"
	err = en.Append(0xa3, 0x72, 0x74, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RmvTagTotal)
	if err != nil {
		err = msgp.WrapError(err, "RmvTagTotal")
		return
	}
	// write "gc"
	err = en.Append(0xa2, 0x67, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.GetTotal)
	if err != nil {
		err = msgp.WrapError(err, "GetTotal")
		return
	}
	// write "hc"
	err = en.Append(0xa2, 0x68, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.HeadTotal)
	if err != nil {
		err = msgp.WrapError(err, "HeadTotal")
		return
	}
	// write "ptf"
	err = en.Append(0xa3, 0x70, 0x74, 0x66)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.PutTagFailedTotal)
	if err != nil {
		err = msgp.WrapError(err, "PutTagFailedTotal")
		return
	}
	// write "gtf"
	err = en.Append(0xa3, 0x67, 0x74, 0x66)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.GetTagFailedTotal)
	if err != nil {
		err = msgp.WrapError(err, "GetTagFailedTotal")
		return
	}
	// write "rtf"
	err = en.Append(0xa3, 0x72, 0x74, 0x66)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RmvTagFailedTotal)
	if err != nil {
		err = msgp.WrapError(err, "RmvTagFailedTotal")
		return
	}
	// write "gf"
	err = en.Append(0xa2, 0x67, 0x66)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.GetFailedTotal)
	if err != nil {
		err = msgp.WrapError(err, "GetFailedTotal")
		return
	}
	// write "hf"
	err = en.Append(0xa2, 0x68, 0x66)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.HeadFailedTotal)
	if err != nil {
		err = msgp.WrapError(err, "HeadFailedTotal")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProxyMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "ptc"
	o = append(o, 0x8a, 0xa3, 0x70, 0x74, 0x63)
	o = msgp.AppendUint64(o, z.PutTagTotal)
	// string "gtc"
	o = append(o, 0xa3, 0x67, 0x74, 0x63)
	o = msgp.AppendUint64(o, z.GetTagTotal)
	// string "rtc"
	o = append(o, 0xa3, 0x72, 0x74, 0x63)
	o = msgp.AppendUint64(o, z.RmvTagTotal)
	// string "gc"
	o = append(o, 0xa2, 0x67, 0x63)
	o = msgp.AppendUint64(o, z.GetTotal)
	// string "hc"
	o = append(o, 0xa2, 0x68, 0x63)
	o = msgp.AppendUint64(o, z.HeadTotal)
	// string "ptf"
	o = append(o, 0xa3, 0x70, 0x74, 0x66)
	o = msgp.AppendUint64(o, z.PutTagFailedTotal)
	// string "gtf"
	o = append(o, 0xa3, 0x67, 0x74, 0x66)
	o = msgp.AppendUint64(o, z.GetTagFailedTotal)
	// string "rtf"
	o = append(o, 0xa3, 0x72, 0x74, 0x66)
	o = msgp.AppendUint64(o, z.RmvTagFailedTotal)
	// string "gf"
	o = append(o, 0xa2, 0x67, 0x66)
	o = msgp.AppendUint64(o, z.GetFailedTotal)
	// string "hf"
	o = append(o, 0xa2, 0x68, 0x66)
	o = msgp.AppendUint64(o, z.HeadFailedTotal)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProxyMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ptc":
			z.PutTagTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PutTagTotal")
				return
			}
		case "gtc":
			z.GetTagTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GetTagTotal")
				return
			}
		case "rtc":
			z.RmvTagTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RmvTagTotal")
				return
			}
		case "gc":
			z.GetTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GetTotal")
				return
			}
		case "hc":
			z.HeadTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeadTotal")
				return
			}
		case "ptf":
			z.PutTagFailedTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PutTagFailedTotal")
				return
			}
		case "gtf":
			z.GetTagFailedTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GetTagFailedTotal")
				return
			}
		case "rtf":
			z.RmvTagFailedTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RmvTagFailedTotal")
				return
			}
		case "gf":
			z.GetFailedTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GetFailedTotal")
				return
			}
		case "hf":
			z.HeadFailedTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeadFailedTotal")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProxyMetric) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 3 + msgp.Uint64Size + 3 + msgp.Uint64Size + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 3 + msgp.Uint64Size + 3 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *QStat) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Count":
			z.Count, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "Bytes":
			z.Bytes, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z QStat) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Count"
	err = en.Append(0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	// write "Bytes"
	err = en.Append(0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Bytes)
	if err != nil {
		err = msgp.WrapError(err, "Bytes")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z QStat) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Count"
	o = append(o, 0x82, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.Count)
	// string "Bytes"
	o = append(o, 0xa5, 0x42, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendFloat64(o, z.Bytes)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *QStat) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Count":
			z.Count, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "Bytes":
			z.Bytes, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z QStat) Msgsize() (s int) {
	s = 1 + 6 + msgp.Float64Size + 6 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicationMRFStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "LastFailedCount":
			z.LastFailedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "LastFailedCount")
				return
			}
		case "TotalDroppedCount":
			z.TotalDroppedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalDroppedCount")
				return
			}
		case "TotalDroppedBytes":
			z.TotalDroppedBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalDroppedBytes")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ReplicationMRFStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "LastFailedCount"
	err = en.Append(0x83, 0xaf, 0x4c, 0x61, 0x73, 0x74, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.LastFailedCount)
	if err != nil {
		err = msgp.WrapError(err, "LastFailedCount")
		return
	}
	// write "TotalDroppedCount"
	err = en.Append(0xb1, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalDroppedCount)
	if err != nil {
		err = msgp.WrapError(err, "TotalDroppedCount")
		return
	}
	// write "TotalDroppedBytes"
	err = en.Append(0xb1, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalDroppedBytes)
	if err != nil {
		err = msgp.WrapError(err, "TotalDroppedBytes")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ReplicationMRFStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "LastFailedCount"
	o = append(o, 0x83, 0xaf, 0x4c, 0x61, 0x73, 0x74, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.LastFailedCount)
	// string "TotalDroppedCount"
	o = append(o, 0xb1, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.TotalDroppedCount)
	// string "TotalDroppedBytes"
	o = append(o, 0xb1, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.TotalDroppedBytes)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicationMRFStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "LastFailedCount":
			z.LastFailedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastFailedCount")
				return
			}
		case "TotalDroppedCount":
			z.TotalDroppedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalDroppedCount")
				return
			}
		case "TotalDroppedBytes":
			z.TotalDroppedBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalDroppedBytes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ReplicationMRFStats) Msgsize() (s int) {
	s = 1 + 16 + msgp.Uint64Size + 18 + msgp.Uint64Size + 18 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SMA) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "CAvg":
			z.CAvg, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "CAvg")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SMA) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "CAvg"
	err = en.Append(0x81, 0xa4, 0x43, 0x41, 0x76, 0x67)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.CAvg)
	if err != nil {
		err = msgp.WrapError(err, "CAvg")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SMA) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "CAvg"
	o = append(o, 0x81, 0xa4, 0x43, 0x41, 0x76, 0x67)
	o = msgp.AppendFloat64(o, z.CAvg)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SMA) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "CAvg":
			z.CAvg, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CAvg")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SMA) Msgsize() (s int) {
	s = 1 + 5 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *XferStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cr":
			z.Curr, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Curr")
				return
			}
		case "av":
			z.Avg, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Avg")
				return
			}
		case "p":
			z.Peak, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Peak")
				return
			}
		case "n":
			z.N, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *XferStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "cr"
	err = en.Append(0x84, 0xa2, 0x63, 0x72)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Curr)
	if err != nil {
		err = msgp.WrapError(err, "Curr")
		return
	}
	// write "av"
	err = en.Append(0xa2, 0x61, 0x76)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Avg)
	if err != nil {
		err = msgp.WrapError(err, "Avg")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Peak)
	if err != nil {
		err = msgp.WrapError(err, "Peak")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *XferStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "cr"
	o = append(o, 0x84, 0xa2, 0x63, 0x72)
	o = msgp.AppendFloat64(o, z.Curr)
	// string "av"
	o = append(o, 0xa2, 0x61, 0x76)
	o = msgp.AppendFloat64(o, z.Avg)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Peak)
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendInt64(o, z.N)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *XferStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cr":
			z.Curr, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Curr")
				return
			}
		case "av":
			z.Avg, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Avg")
				return
			}
		case "p":
			z.Peak, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Peak")
				return
			}
		case "n":
			z.N, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *XferStats) Msgsize() (s int) {
	s = 1 + 3 + msgp.Float64Size + 3 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Int64Size
	return
}
