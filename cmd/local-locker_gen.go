// Code generated by github.com/tinylib/msgp DO NOT EDIT.

package cmd

import (
	"time"

	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *localLockMap) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0004 uint32
	zb0004, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(localLockMap, zb0004)
	} else if len((*z)) > 0 {
		clear((*z))
	}
	var field []byte
	_ = field
	for zb0004 > 0 {
		zb0004--
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0002 []lockRequesterInfo
		var zb0005 uint32
		zb0005, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		if cap(zb0002) >= int(zb0005) {
			zb0002 = (zb0002)[:zb0005]
		} else {
			zb0002 = make([]lockRequesterInfo, zb0005)
		}
		for zb0003 := range zb0002 {
			err = zb0002[zb0003].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, zb0001, zb0003)
				return
			}
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z localLockMap) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0006, zb0007 := range z {
		err = en.WriteString(zb0006)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		err = en.WriteArrayHeader(uint32(len(zb0007)))
		if err != nil {
			err = msgp.WrapError(err, zb0006)
			return
		}
		for zb0008 := range zb0007 {
			err = zb0007[zb0008].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, zb0006, zb0008)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z localLockMap) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for zb0006, zb0007 := range z {
		o = msgp.AppendString(o, zb0006)
		o = msgp.AppendArrayHeader(o, uint32(len(zb0007)))
		for zb0008 := range zb0007 {
			o, err = zb0007[zb0008].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, zb0006, zb0008)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *localLockMap) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0004 uint32
	zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(localLockMap, zb0004)
	} else if len((*z)) > 0 {
		clear((*z))
	}
	var field []byte
	_ = field
	for zb0004 > 0 {
		var zb0002 []lockRequesterInfo
		zb0004--
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0005 uint32
		zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		if cap(zb0002) >= int(zb0005) {
			zb0002 = (zb0002)[:zb0005]
		} else {
			zb0002 = make([]lockRequesterInfo, zb0005)
		}
		for zb0003 := range zb0002 {
			bts, err = zb0002[zb0003].UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001, zb0003)
				return
			}
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z localLockMap) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0006, zb0007 := range z {
			_ = zb0007
			s += msgp.StringPrefixSize + len(zb0006) + msgp.ArrayHeaderSize
			for zb0008 := range zb0007 {
				s += zb0007[zb0008].Msgsize()
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *lockRequesterInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Writer":
			z.Writer, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Writer")
				return
			}
		case "UID":
			z.UID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "Timestamp":
			z.Timestamp, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "TimeLastRefresh":
			z.TimeLastRefresh, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TimeLastRefresh")
				return
			}
		case "Source":
			z.Source, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "Group":
			z.Group, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "Owner":
			z.Owner, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "Quorum":
			z.Quorum, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Quorum")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *lockRequesterInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "Name"
	err = en.Append(0x89, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "Writer"
	err = en.Append(0xa6, 0x57, 0x72, 0x69, 0x74, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Writer)
	if err != nil {
		err = msgp.WrapError(err, "Writer")
		return
	}
	// write "UID"
	err = en.Append(0xa3, 0x55, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.UID)
	if err != nil {
		err = msgp.WrapError(err, "UID")
		return
	}
	// write "Timestamp"
	err = en.Append(0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Timestamp)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	// write "TimeLastRefresh"
	err = en.Append(0xaf, 0x54, 0x69, 0x6d, 0x65, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TimeLastRefresh)
	if err != nil {
		err = msgp.WrapError(err, "TimeLastRefresh")
		return
	}
	// write "Source"
	err = en.Append(0xa6, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Source)
	if err != nil {
		err = msgp.WrapError(err, "Source")
		return
	}
	// write "Group"
	err = en.Append(0xa5, 0x47, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Group)
	if err != nil {
		err = msgp.WrapError(err, "Group")
		return
	}
	// write "Owner"
	err = en.Append(0xa5, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Owner)
	if err != nil {
		err = msgp.WrapError(err, "Owner")
		return
	}
	// write "Quorum"
	err = en.Append(0xa6, 0x51, 0x75, 0x6f, 0x72, 0x75, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Quorum)
	if err != nil {
		err = msgp.WrapError(err, "Quorum")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *lockRequesterInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "Name"
	o = append(o, 0x89, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "Writer"
	o = append(o, 0xa6, 0x57, 0x72, 0x69, 0x74, 0x65, 0x72)
	o = msgp.AppendBool(o, z.Writer)
	// string "UID"
	o = append(o, 0xa3, 0x55, 0x49, 0x44)
	o = msgp.AppendString(o, z.UID)
	// string "Timestamp"
	o = append(o, 0xa9, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o = msgp.AppendInt64(o, z.Timestamp)
	// string "TimeLastRefresh"
	o = append(o, 0xaf, 0x54, 0x69, 0x6d, 0x65, 0x4c, 0x61, 0x73, 0x74, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68)
	o = msgp.AppendInt64(o, z.TimeLastRefresh)
	// string "Source"
	o = append(o, 0xa6, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65)
	o = msgp.AppendString(o, z.Source)
	// string "Group"
	o = append(o, 0xa5, 0x47, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendBool(o, z.Group)
	// string "Owner"
	o = append(o, 0xa5, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Owner)
	// string "Quorum"
	o = append(o, 0xa6, 0x51, 0x75, 0x6f, 0x72, 0x75, 0x6d)
	o = msgp.AppendInt(o, z.Quorum)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *lockRequesterInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Writer":
			z.Writer, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Writer")
				return
			}
		case "UID":
			z.UID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "Timestamp":
			z.Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		case "TimeLastRefresh":
			z.TimeLastRefresh, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TimeLastRefresh")
				return
			}
		case "Source":
			z.Source, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Source")
				return
			}
		case "Group":
			z.Group, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "Owner":
			z.Owner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Owner")
				return
			}
		case "Quorum":
			z.Quorum, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Quorum")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *lockRequesterInfo) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.BoolSize + 4 + msgp.StringPrefixSize + len(z.UID) + 10 + msgp.Int64Size + 16 + msgp.Int64Size + 7 + msgp.StringPrefixSize + len(z.Source) + 6 + msgp.BoolSize + 6 + msgp.StringPrefixSize + len(z.Owner) + 7 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *lockStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Total":
			z.Total, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		case "Writes":
			z.Writes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Writes")
				return
			}
		case "Reads":
			z.Reads, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Reads")
				return
			}
		case "LockQueue":
			z.LockQueue, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LockQueue")
				return
			}
		case "LocksAbandoned":
			z.LocksAbandoned, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LocksAbandoned")
				return
			}
		case "LastCleanup":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LastCleanup")
					return
				}
				z.LastCleanup = nil
			} else {
				if z.LastCleanup == nil {
					z.LastCleanup = new(time.Time)
				}
				*z.LastCleanup, err = dc.ReadTime()
				if err != nil {
					err = msgp.WrapError(err, "LastCleanup")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *lockStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "Total"
	err = en.Append(0x86, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Total)
	if err != nil {
		err = msgp.WrapError(err, "Total")
		return
	}
	// write "Writes"
	err = en.Append(0xa6, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Writes)
	if err != nil {
		err = msgp.WrapError(err, "Writes")
		return
	}
	// write "Reads"
	err = en.Append(0xa5, 0x52, 0x65, 0x61, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Reads)
	if err != nil {
		err = msgp.WrapError(err, "Reads")
		return
	}
	// write "LockQueue"
	err = en.Append(0xa9, 0x4c, 0x6f, 0x63, 0x6b, 0x51, 0x75, 0x65, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LockQueue)
	if err != nil {
		err = msgp.WrapError(err, "LockQueue")
		return
	}
	// write "LocksAbandoned"
	err = en.Append(0xae, 0x4c, 0x6f, 0x63, 0x6b, 0x73, 0x41, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LocksAbandoned)
	if err != nil {
		err = msgp.WrapError(err, "LocksAbandoned")
		return
	}
	// write "LastCleanup"
	err = en.Append(0xab, 0x4c, 0x61, 0x73, 0x74, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70)
	if err != nil {
		return
	}
	if z.LastCleanup == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteTime(*z.LastCleanup)
		if err != nil {
			err = msgp.WrapError(err, "LastCleanup")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *lockStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "Total"
	o = append(o, 0x86, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
	o = msgp.AppendInt(o, z.Total)
	// string "Writes"
	o = append(o, 0xa6, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73)
	o = msgp.AppendInt(o, z.Writes)
	// string "Reads"
	o = append(o, 0xa5, 0x52, 0x65, 0x61, 0x64, 0x73)
	o = msgp.AppendInt(o, z.Reads)
	// string "LockQueue"
	o = append(o, 0xa9, 0x4c, 0x6f, 0x63, 0x6b, 0x51, 0x75, 0x65, 0x75, 0x65)
	o = msgp.AppendInt(o, z.LockQueue)
	// string "LocksAbandoned"
	o = append(o, 0xae, 0x4c, 0x6f, 0x63, 0x6b, 0x73, 0x41, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x64)
	o = msgp.AppendInt(o, z.LocksAbandoned)
	// string "LastCleanup"
	o = append(o, 0xab, 0x4c, 0x61, 0x73, 0x74, 0x43, 0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70)
	if z.LastCleanup == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendTime(o, *z.LastCleanup)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *lockStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Total":
			z.Total, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		case "Writes":
			z.Writes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Writes")
				return
			}
		case "Reads":
			z.Reads, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reads")
				return
			}
		case "LockQueue":
			z.LockQueue, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LockQueue")
				return
			}
		case "LocksAbandoned":
			z.LocksAbandoned, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LocksAbandoned")
				return
			}
		case "LastCleanup":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastCleanup = nil
			} else {
				if z.LastCleanup == nil {
					z.LastCleanup = new(time.Time)
				}
				*z.LastCleanup, bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastCleanup")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *lockStats) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 7 + msgp.IntSize + 6 + msgp.IntSize + 10 + msgp.IntSize + 15 + msgp.IntSize + 12
	if z.LastCleanup == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	return
}
